%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Tutorial}\label{chap:tuto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following chapter describes the usage of the PFFT library corresponding to the simple test files,
that are included in the library. If you are interested in the more advanced features of PFFT you
should also have a look at chapter~\ref{chap:feat}.

\section{Some Comments on MPI/FFTW}

The PFFT library was designed for distributed memory architectures and was implemented based on the Message Passing Interface (MPI).
We assume that the user of PFFT is at least familiar with the basics of the MPI programming paradigm.
Nevertheless, we explain some of the basic MPI concepts whenever they are important to understand
the design of the PFFT library. We tried to hide most of the parallel coding details from the user,
but of course this is limited by the fact that PFFT itself is a parallel software library.
For more details on the MPI programming language we refer to the MPI Standard~\cite{MPI-2.2}, see also \cite{GrLuTh99} for detailed explanations.
Since the PFFT interface was written as close as possible to the FFTW interface, the user will benefit from


Furthermore, you should be familiar with the usage of the FFTW software library,


The MPI standard introduces the term process to indicate a \\
The term process abstracts form the widely used terms processors and nodes. \\
Throughout this manual we will adapt to the MPI standard and use the term process to indicate the smallest \\
Note that the term process abstracts the code development from the real physical architecture. For example we can \\
At first glance, it seems to be artificial to \\
\emph{An MPI program consists of autonomous processes, executing their own code, in an MIMD style.}
( MPI: A Message-Passing Interface Standard, page 27)
\begin{compactitem}
  \item process (identified in most cases with processors/nodes/cores)
  \item plan
\end{compactitem}



After initializing MPI and before calling any PFFT routine PFFT must be initialized via
\begin{lstlisting}
void pfft_init(void);
\end{lstlisting}
However, this is nothing else than a wrapper to the \code{fftw\_mpi\_init} routine.

PFFT uses a two-dimensional data decomposition on a two-dimensional process grid.

MPI introduces the concept of communicators
to store all the topological information of the physical process layout. PFFT assumes to be called
on a two-dimensional process mesh that corresponds to a periodic, two-dimensional Cartesian
communicator. We assist the user in creating such communicator with the following routine
\begin{lstlisting}
int pfft_create_procmesh_2d(
    MPI_Comm comm, int np0, int np1,
    MPI_Comm *comm_cart_2d);
\end{lstlisting}
This routine uses the processes within the communicator \code{comm} to create a two-dimensional process
grid of size \code{np0} x \code{np1} and stores it into the Cartesian communicator
\code{comm\_cart\_2d}. Since \code{comm\_cart\_2d} is allocated by the routine, the user has to provide
the pointer to a non-allocated communicator. Otherwise we end up with a memory leak.
Most users will choose \code{comm} as \code{MPI\_COMM\_WORLD}, which implies that the DFT is computed
on all available processes. Nevertheless, it's important to note, that we follow the principles of MPI
by allowing \code{comm} to be any arbitrary communicator and therefore any subset of the available processes.

At the next step we need to know the data decomposition of the input and output array, that depends on
the array sizes, the process grid and the parallel algorithm.
\begin{lstlisting}
ptrdiff_t pfft_local_size_3d(
    ptrdiff_t *n, MPI_Comm comm_cart_2d, unsigned pfft_flags,
    ptrdiff_t *local_ni, ptrdiff_t *local_i_start,
    ptrdiff_t *local_no, ptrdiff_t *local_o_start);
\end{lstlisting}
This function returns the size of the local complex array that needs to be allocated by every process to
execute PFFT. In most cases, this coincides with the product of the local array sizes, but according to the FFTW
manual it may be bigger, if the parallel algorithm needs some extra storage to be executed.
Since the data layout of the input and output array differ, the algorithm differ for forward and backward
DFTs. \emph{Unterschied zu FFTW forward und backward deutlich machen}

Next the input and output arrays must be allocated. For performance reasons this should be done using
\begin{lstlisting}
void *fftw_malloc(size_t size);
\end{lstlisting}
Nevertheless, you can also use any other dynamic memory allocation. Have a look at the FFTW user manual~\cite{FFTW05}
for more details.

The planning of a single three-dimensional parallel DFT of size \code{n[0]} x \code{n[1]} x \code{n[2]} is done by the function
\begin{lstlisting}
pfft_plan pfft_plan_dft_3d(
    ptrdiff_t *n, fftw_complex *in, fftw_complex *out,
    MPI_Comm comm_cart_2d, int sign,
    unsigned pfft_flags, unsigned fftw_flags);
\end{lstlisting}
We provide the address of the input and output array by the pointers \code{in} and \code{out},
respectively. An inplace transform is assumed if these pointers are equal. As mentioned above,
PFFT calculates the DFT on a periodic, two-dimensional Cartesian communicator \code{comm\_cart\_2d}.
We recommend to use \code{pfft\_create\_procmesh\_2d} to generate an appropriate communicator.
Similar to FFTW the integer \code{sign} gives the sign in the exponential of the DFT. The
\code{pfft\_flags} must coincide with the flags that were used to call \code{pfft\_local\_size\_3d}.
Otherwise the data layout may not match the offset parameters. The last argument \code{fftw\_flags}
can be used to adjust the planning effort. Note that except for \code{FFTW\_ESTIMATE} the input and
output array may be overwritten during the planning.


During the initialization of the input, one has to take into account the parallel decomposition.
\emph{show how to fill 3d data into 1d array with offsets - is this too detailed stuff???}

\begin{lstlisting}
void pfft_init_input_3d(
    ptrdiff_t *n, ptrdiff_t *local_ni, ptrdiff_t *local_i_start,
    MPI_Comm comm_cart_2d,
    fftw_complex *in);
\end{lstlisting}



Executing the plan is now very easy.
\begin{lstlisting}
void pfft_execute(pfft_plan plan);
\end{lstlisting}

Finally we free the allocated memory
\begin{lstlisting}
void pfft_destroy_plan(pfft_plan plan);
\end{lstlisting}

Use
\begin{lstlisting}
void fftw_free(void *ptr);
\end{lstlisting}
to free memory allocated by \code{fftw\_malloc}.

\subsubsection*{ToDo}
\begin{compactitem}
  \item describe data offsets somewhere (maybe already in the introduction?)
  \item move details into features chapter
  \item do backward transform in minimal test??? (better shows the usage of forward and backward flags)
  \item adjust line breaks in minimal test that they look nice in latex
  \item adjust line numbers in code fracments(?)
\end{compactitem}

\emph{Install and usage:} (separate chapter)
\begin{compactitem}
  \item 
  \item[\mybox] make shure that the preprocessor can find \code{fftw3.h} and \code{fftw3-mpi.h}
  \item[\mybox] use a MPI compiler wrapper, or make mpi libraries and header available
\end{compactitem}





\newpage
\subsection{PFFT Interface Layer Specification}
\begin{compactitem}
  \myitem start with internal interface and simplify it into basic interface
\end{compactitem}


\emph{Gcell Internal Interface}
\begin{compactitem}
  \item[+] \verb++
  \item[+] \verb++
  \item[+] \verb++
\end{compactitem}




\emph{Basic Interface}
\begin{compactitem}
  \item[+] \verb+const INT *n+
  \item[+] \verb+C *in+
  \item[+] \verb+C *out+
  \item[+] \verb+MPI\_Comm comm\_cart\_2d+
  \item[+] \verb+int sign+
  \item[+] \red{unsigned pfft\_flags}
  \item[+] \verb+unsigned fftw\_flags+
\end{compactitem}

\emph{3D Basic Interface}
\begin{compactitem}
  \item[-] \verb+const INT *n+
  \item[+] \verb+INT n0, n1, n2+
\end{compactitem}

\emph{3D Basic Interface Transposed}
\begin{compactitem}
  \item[-] \verb+const INT *n+
  \item[+] \verb+INT n0, n1, n2+
  \item[+] \red{unsigned pfft\_flags}
\end{compactitem}

\emph{Advanced Interface}
\begin{compactitem}
  \item[+] \verb+const INT *ni+
  \item[+] \verb+const INT *no+
  \item[+] \verb+INT howmany+
  \item[+] \verb+const INT *block_col+
  \item[+] \verb+const INT *block_row+
\end{compactitem}

\emph{Guru Interface}
\begin{compactitem}
  \item[-] \red{unsigned pfft\_flags}
  \item[+] \verb+pfft\_profile *prf+
  \item[+] \verb+pfft\_permutation *perm+
\end{compactitem}

\emph{Internal Interface}
\begin{compactitem}
  \item[$-$] \verb+MPI_Comm comm_cart_2d+
  \item[+] \red{MPI\_Comm comm\_col}
  \item[+] \red{MPI\_Comm comm\_row}
  \item[+] \verb+pfft_truncation *trc+
  \item[+] \verb+user_blocksize+ $\Rightarrow$ \verb+block_size_internal+
  \item[+] \verb+howmany+ $\Rightarrow$ \verb+tuplesize+
  \item[+] \verb+fftw_flags+ $\Rightarrow$ \verb+fftw_planing_flags+
\end{compactitem}


\newcommand{\redlst}[1]{\lstinline+#1+}

\newpage
\subsection{PFFT Interface - Headers}
\emph{New PFFT Interface: local size (Internal, Guru, Adv, Basic, 3d, 2d)}
\begin{lstlisting}
INT PX(local_size_internal)(
    int (*@\color{red}rnk\_nc@*), const INT *n, const INT *ni, const INT *no,
    INT (*@\color{red}tuple\_size@*), const INT *iblock, const INT *oblock,
    int (*@\color{red}rnk\_pm@*), MPI_Comm (*@\color{red}*comms\_pm@*),
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);
// blocks are internal blocks (NULLs are substituted by default values)
// use MPI_Cart_split multiple times to get comms_1d
// canonical PFFT:
// one more array dimension, than procmesh dimension
// tuple_size includes howmany and the last dimensions

INT PX(local_size_guru)(
    int rnk, const INT *n, const INT *ni, const INT *no,
    const (*@\red{PX(profile) *prf}@*), const (*@\color{red}PX(permutation) *perm@*),
    INT (*@\color{green}howmany@*), const INT *iblock, const INT *oblock,
    MPI_Comm (*@\color{green}comm\_cart@*),
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start,
    PX(permutation) (*@\color{orange}*perm\_out)@*);
/* !!! prf depends on perm !!! */
/* !!! oblock depends on perm, prf, no !!! */

INT PX(local_size_many_transposed)(
    int rnk, const INT *n, const INT (*@\color{red}*ni@*), const INT (*@\color{red}*no@*),
    INT (*@\color{red}howmany@*), const INT (*@\color{red}*iblock@*), const INT (*@\color{red}*oblock@*),
    MPI_Comm comm_cart
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);
INT PX(local_size_many)(
    int rnk, const INT *n, const INT (*@\color{red}*ni@*), const INT (*@\color{red}*no@*),
    INT (*@\color{red}howmany@*), const INT (*@\color{red}*iblock@*), const INT (*@\color{red}*oblock@*),
    MPI_Comm comm_cart
    INT *local_ni, INT *local_i_start,
    INT (*@\color{red}*local\_no@*), INT (*@\color{red}*local\_o\_start@*));

INT PX(local_size_transposed)(
    int (*@\color{red}rnk@*), const INT (*@\color{red}*n@*), MPI_Comm comm_cart,
    INT (*@\color{red}*local\_ni@*), INT (*@\color{red}*local\_i\_start@*)
    INT (*@\color{red}*local\_no@*), INT (*@\color{red}*local\_o\_start@*));
INT PX(local_size)(
    int (*@\color{red}rnk@*), const INT (*@\color{red}*n@*), MPI_Comm comm_cart,
    INT (*@\color{red}*local\_ni@*), INT (*@\color{red}*local\_i\_start@*));

INT PX(local_size_3d_transposed)(
    INT (*@\color{green}n0@*), INT (*@\color{green}n1@*), (*@\color{orange}INT n2@*), MPI_Comm (*@\color{red}comm\_cart@*),
    INT (*@\color{green}*local\_ni0@*), INT (*@\color{green}*local\_i0\_start@*),
    INT (*@\color{orange}*local\_ni1@*), INT (*@\color{orange}*local\_i1\_start@*),
    INT (*@\color{green}*local\_no1@*), INT (*@\color{green}*local\_o1\_start@*),
    INT (*@\color{orange}*local\_no2@*), INT (*@\color{orange}*local\_o2\_start@*));
INT PX(local_size_3d)(
    INT (*@\color{green}n0@*), INT (*@\color{green}n1@*), (*@\color{orange}INT n2@*), MPI_Comm (*@\color{red}comm\_cart@*),
    INT (*@\color{green}*local\_n0@*), INT (*@\color{green}*local\_0\_start@*),
    INT (*@\color{orange}*local\_n1@*), INT (*@\color{orange}*local\_1\_start@*));

INT PX(local_size_2d_transposed)(
    INT n0, INT n1, MPI_Comm (*@\color{green}comm@*),
    INT *local_ni0, INT *local_i0_start,
    INT *local_no1, INT *local_o1_start);
INT PX(local_size_2d)(
    INT n0, INT n1, MPI_Comm (*@\color{green}comm@*),
    INT *local_n0, INT *local_0_start);
/* allow arbitrary comm for backward compatibility with FFTW */
\end{lstlisting}


\emph{New PFFT interface: plan (Guru, Adv, Basic, 3d, 2d)}
\begin{lstlisting}
PX(plan) PX(plan_guru_dft)(
    int rnk, const INT *n, const INT *ni, const INT *no,
    const PX(profile) (*@\color{red}*prf@*), const PX(permutation) (*@\color{red}*perm@*),
    INT howmany, const INT *iblock, const INT *oblock,
    C *data_in, C *data_out,
    MPI_Comm comm_cart,
    int sign, unsigned fftw_flags);
/* !!! prf depends on perm !!! */
/* !!! oblock depends on perm, prf, no !!! */

PX(plan) PX(plan_many_dft)(
    int rnk, const INT *n, const INT (*@\color{red}*ni@*), const INT (*@\color{red}*no@*),
    INT (*@\color{red}howmany@*), const INT (*@\color{red}*iblock@*), const INT (*@\color{red}*oblock@*),
    C *data_in, C *data_out,
    MPI_Comm comm_cart,
    int sign, unsigned pfft_flags, unsigned fftw_flags);

PX(plan) PX(plan_dft)(
    int (*@\color{red}rnk@*), const INT (*@\color{red}*n@*),
    C *data_in, C *data_out,
    MPI_Comm comm_cart,
    int sign, unsigned pfft_flags, unsigned fftw_flags);

PX(plan) PX(plan_dft_3d)(
    INT (*@\color{green}n0@*), INT (*@\color{green}n1@*), INT (*@\color{orange}n2@*),
    C *data_in, C *data_out,
    MPI_Comm (*@\color{red}comm\_cart@*),
    int sign, unsigned pfft_flags, unsigned fftw_flags);
PX(plan) PX(plan_dft_2d)(
    INT n0, INT n1, C *data_in, C *data_out,
    MPI_Comm (*@\color{green}comm@*),
    int sign, unsigned pfft_flags, unsigned fftw_flags);
/* allow arbitrary comm for backward compatibility with FFTW */
\end{lstlisting}

\emph{Interface Layer Names (Like FFTW):}
\begin{lstlisting}
local_size[_internal, _guru, _many][_3d, _2d][_transposed]
plan[_internal, _guru, _many]_dft[_3d, _2d]
local_size[_internal, _guru, _many]_gc[_3d, _2d]
plan[_internal, _guru, _many]_gc[_3d, _2d]
\end{lstlisting}

\emph{Interface Layer Names (Like FFTW) - Merged FFT and GC:}
\begin{lstlisting}
local_size[_internal, _guru, _many][_gc][_3d, _2d][_transposed]
plan[_internal, _guru, _many][_dft, _gc][_3d, _2d]
\end{lstlisting}
No need for \lstinline{local_size[_dft, _rdft]}, since we put the physical dimensions into local size.


\newpage
\emph{Interface Layer Specification - Local Size:}
\begin{lstlisting}

C-types: int, const INT *, const PX(truncation) *, const PX(profile) *, const PX(permutation) *,
         R, C, INT, INT *, MPI_Comm, unsigned
F-types:

GetParam_LAYER(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

GetParam_Internal(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Set all parameters for the most abstract layer */
  RNK_N = {int rnk, const INT *n}
  TRC = {const PX(truncation) *trc}
  PRF_PERM = {const PX(profile) *prf, const PX(permutation) *perm}
  HOWMANY_BLOCKS = {INT howmany, const INT *iblock, const INT *oblock}
  DATA =
  COMM = {int rnk_comm, MPI_Comm comms_1d}
  SIGN =
  FLAGS =
  OUT_LOCN = {INT *local_ni, INT *local_i_start,\n  INT *local_no, INT *local_o_start}
  OUT_PERM =
}

GetParam_Guru, RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Get the parameters of the above layer */
  GetParam_Internal(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

  /* Change Parameters according to the current layer */
  Subst(TRC, {const PX(truncation) *trc}, {const INT *ni, const INT *no})
  Subst(COMM, {int rnk_comm, MPI_Comm comms_1d}, {MPI_Comm comm_cart})
  OUT_PERM = {PX(permutation) *perm_out}
}

GetParam_Adv(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Get the parameters of the above layer */
  GetParam_Guru(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

  /* Change Parameters according to the current layer */
  Free(PRF_PERM, {const PX(profile) *prf, const PX(permutation) *perm})
  Free(OUT_PERM, {PX(permutation) *perm_out})
  (*@\color{red}/* use second arg of Free for check */@*)
}

GetParam_Basic(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Get the parameters of the above layer */
  GetParam_Adv(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

  /* Change Parameters according to the current layer */
  Free(TRC, {const INT *ni, const INT *no});
  Free(HOWMANY_BLOCKS,
    {INT howmany, const INT *iblock, const INT *oblock});
}

GetParam_3d(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Get the parameters of the above layer */
  GetParam_Basic(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

  /* Change Parameters according to the current layer */
  Subst(RNK_N, {int rnk, const INT *n}, {INT n0, INT n1, INT n2})
  Subst(OUT_LOCN,
    {INT *local_ni, INT *local_i_start,
     INT *local_no, INT *local_o_start},
    {INT *local_n0, INT *local_0_start,
     INT *local_n1, INT *local_1_start})
}

GetParam_2d(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM){
  /* Get the parameters of the above layer */
  GetParam_Basic(RNK_N, TRC, PRF_PERM, HOWMANY_BLOCKS, DATA, COMM, SIGN, FLAGS, OUT_LOCN, OUT_PERM)

  /* Change Parameters according to the current layer */
  Subst(RNK_N, {int rnk, const INT *n}, {INT n0, INT n1})
  Subst(OUT_LOCN,
    {INT *local_ni, INT *local_i_start,
     INT *local_no, INT *local_o_start},
    {INT *local_n0, INT *local_0_start})
}



\end{lstlisting}


\newpage
\emph{New PFFT GCell Interface: local size (Basic, Advanced)}
\begin{lstlisting}
INT PX(gc_local_size_internal)(
    int rnk, const INT *loc_array_size, INT tuple_size,
    const INT *gc_below, const INT *gc_above);

INT PX(gc_local_size_many)(
    int rnk, const INT *local_n, const INT *local_start,
    INT alloc_local, INT howmany,
    const INT *num_gcells_below, const INT *num_gcells_above,
    INT *local_ngc, INT *local_gc_start);

INT PX(gc_local_size)(
    int rnk, const INT *local_n, const INT *local_start,
    INT alloc_local,
    const INT *gc_below, const INT *gc_above,
    INT *local_ngc, INT *local_gc_start);
\end{lstlisting}


\emph{New PFFT GCell Interface: plan (Basic, Advanced, Guru, Internal)}
\begin{lstlisting}
PX(gcplan) PX(plan_gcells_internal)(
    int rnk, const INT *n, const PX(permutation) *perm,
    INT howmany, const INT *block,
    const INT *gc_below, const INT *gc_above,
    R *data, MPI_Comm *comms_1d, MPI_Comm comm_cart,
    unsigned gcflags);
// tuple_size = 2*howmany*last_dims

PX(gcplan) PX(plan_guru_gc)(
    int rnk, const INT *n, const PX(permutation) *perm,
    INT howmany, const INT *block,
    const INT *gc_below, const INT *gc_above,
    C *data, MPI_Comm comm_cart, unsigned gcflags);
// gcflags in {ESTIMATE, MEASURE, PATIENT}
//          x {INPLACE, OUTOFPLACE} x {GC_RMA, GC_SENDRECV}
// default: flags = OUTOFPLACE
//          flags += GC_RMA (if possible) otherwise GC_SENDRECV (always possible)
/* !!! block depends on perm !!! */

PX(gcplan) PX(plan_many_gc)(
    int rnk, const INT *n,
    INT howmany, const INT *block,
    const INT *gc_below, const INT *gc_above,
    C *data, MPI_Comm comm_cart, unsigned gcflags);
// gcflags in {NONTRANSPOSED, TRANSPOSED} x {ESTIMATE, MEASURE, PATIENT}
//          x {INPLACE, OUTOFPLACE} x {GC_RMA, GC_SENDRECV}
// default: flags = NONTRANSPOSED

PX(gcplan) PX(plan_gc)(
    int rnk, const INT *n,
    const INT *gc_below, const INT *gc_above,
    C *data, MPI_Comm comm_cart, unsigned gcflags);
// gcflags in {NONTRANSPOSED, TRANSPOSED} x {ESTIMATE, MEASURE, PATIENT}
//          x {INPLACE, OUTOFPLACE} x {GC_RMA, GC_SENDRECV}
\end{lstlisting}



\emph{Tasks:}
\begin{compactitem}
  \item generate the headers from PFFT interface layer specification automatically
  \item generate pfft.h
  \begin{compactitem}
    \item Header: add \verb+PFFT_EXTERN+
    \item Header: add \verb+\+ at end of line
  \end{compactitem}
  \item where to put in the layer specific functions?
  \begin{compactitem}
    \item \verb+void pfft_init(void)+
    \item \verb+void pfft_cleanup(void)+
  \end{compactitem}
\end{compactitem}




\newpage
\emph{Old PFFT interface: local size (Internal, Guru, Adv, Basic, 3d)}
\begin{verbatim}
INT PX(local_size_dft_3d_internal)(
    const INT *n, const PX(profile) *prf,
    const PX(truncation) *trc, const PX(permutation) *perm,
    INT howmany, const INT *block_col, const INT *block_row,
    MPI_Comm comm_col, MPI_Comm comm_row,
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);

INT PX(local_size_guru)(
    int rank, const INT *n, const INT *ni, const INT *no,
    const PX(profile) *prf, const PX(permutation) *perm,
    INT howmany, const INT *block_col, const INT *block_row,
    MPI_Comm comm_cart,
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start,
    PX(permutation)* perm_out);

INT PX(local_size_many)(
    int rank, const INT *n, const INT *ni, const INT *no,
    INT howmany, const INT *block_col, const INT *block_row,
    MPI_Comm comm_cart_2d,
    unsigned pfft_flags,
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);

INT PX(local_size)(
    int rank, const INT *n, MPI_Comm comm_cart_2d, unsigned pfft_flags,
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);

INT PX(local_size_3d)(
    const INT *n, MPI_Comm comm_cart_2d, unsigned pfft_flags,
    INT *local_ni, INT *local_i_start,
    INT *local_no, INT *local_o_start);
\end{verbatim}

\emph{Old PFFT interface: plan (Internal, Guru, Adv, Basic, 3d)}
\begin{verbatim}
PX(plan) PX(plan_guru_dft)(
    int rank, const INT *n, const INT *ni, const INT *no,
    const PX(profile) *prf, const PX(permutation) *perm,
    INT howmany, const INT *block_col, const INT *block_row,
    C *data_in, C *data_out,
    MPI_Comm comm_cart_2d,
    int sign, unsigned fftw_flags);

PX(plan) PX(plan_many_dft)(
    int rank, const INT *n, const INT *ni, const INT *no,
    INT howmany, const INT *block_col, const INT *block_row,
    C *data_in, C *data_out,
    MPI_Comm comm_cart_2d,
    int sign, unsigned pfft_flags, unsigned fftw_flags);

PX(plan) PX(plan_dft)(
    int rank, const INT *n, C *data_in, C *data_out,
    MPI_Comm comm_cart_2d,
    int sign, unsigned pfft_flags, unsigned fftw_flags);

PX(plan) PX(plan_dft_3d)(
    const INT *n, C *data_in, C *data_out,
    MPI_Comm comm_cart_2d,
    int sign, unsigned pfft_flags, unsigned fftw_flags);
\end{verbatim}

\emph{Old PFFT GCell interface: local size (3d, Basic, Advanced, Guru, Internal)}
\begin{verbatim}
INT PX(local_size_gcells_3d)(
    const INT *local_n, const INT *local_start, INT alloc_local,
    const INT *num_gcells_below, const INT *num_gcells_above,
    INT *local_ngc, INT *local_gc_start);
INT PX(local_size_gcells)(
    int rank, const INT *local_n, const INT *local_start, INT alloc_local,
    const INT *num_gcells_below, const INT *num_gcells_above,
    INT *local_ngc, INT *local_gc_start);
INT PX(local_size_many_gcells)(
    int rank, const INT *local_n, const INT *local_start, INT alloc_local,
    INT howmany, const INT *num_gcells_below, const INT *num_gcells_above,
    INT *local_ngc, INT *local_gc_start);
INT PX(local_size_gcells_guru)(
    int rank, const INT *local_n, const INT *local_start, INT alloc_local,
    INT howmany, const INT *num_gcells_below, const INT *num_gcells_above,
    INT *local_ngc, INT *local_gc_start);
INT PX(local_size_gcells_internal)(
    const INT *localArraySize, INT tupleSize,
    const INT *numGhostCellsBelow, const INT *numGhostCellsAbove);
\end{verbatim}

\emph{Old PFFT GCell interface: plan}
\begin{verbatim}
PX(gcplan) PX(plan_gcells_3d)(
    const INT *n,
    const INT *num_gcells_below, const INT *num_gcells_above,
    C *data, MPI_Comm comm_cart_2d, unsigned pfft_flags);
PX(gcplan) PX(plan_gcells)(
    int rank, const INT *n,
    const INT *num_gcells_below, const INT *num_gcells_above,
    C *data, MPI_Comm comm_cart_2d, unsigned pfft_flags);
PX(gcplan) PX(plan_many_gcells)(
    int rank, const INT *n,
    INT howmany, const INT *block_col, const INT *block_row,
    const INT *num_gcells_below, const INT *num_gcells_above,
    C *data, MPI_Comm comm_cart_2d, unsigned pfft_flag);
PX(gcplan) PX(plan_gcells_guru)(
    int rank, const INT *n, const PX(permutation) *perm,
    INT howmany, const INT *block_col, const INT *block_row,
    const INT *num_gcells_below, const INT *num_gcells_above,
    C *data, MPI_Comm comm_cart_2d, unsigned alg_flags);
PX(gcplan) PX(plan_gcells_internal)(
    const INT *n, const PX(permutation) *perm,
    INT tuple_size, const INT *block_col, const INT *block_row,
    const INT *gcells_below, const INT *gcells_above,
    R *data, MPI_Comm comm_col, MPI_Comm comm_row, MPI_Comm comm_cart_2d,
    unsigned alg_flag);
\end{verbatim}


\newpage
\emph{FFTW Advanced interface:}
\begin{verbatim}
ptrdiff_t XM(local_size_many_transposed)
     (int rnk, const ptrdiff_t *n,
      ptrdiff_t howmany, ptrdiff_t block0, ptrdiff_t block1,
      MPI_Comm comm,
      ptrdiff_t *local_n0, ptrdiff_t *local_0_start,
      ptrdiff_t *local_n1, ptrdiff_t *local_1_start);
ptrdiff_t XM(local_size_many)
     (int rnk, const ptrdiff_t *n, ptrdiff_t howmany,
      ptrdiff_t block0, MPI_Comm comm,
      ptrdiff_t *local_n0, ptrdiff_t *local_0_start);
\end{verbatim}
\emph{FFTW Basic interface:}
\begin{verbatim}
ptrdiff_t XM(local_size_transposed)
     (int rnk, const ptrdiff_t *n, MPI_Comm comm,
      ptrdiff_t *local_n0, ptrdiff_t *local_0_start,
      ptrdiff_t *local_n1, ptrdiff_t *local_1_start);
ptrdiff_t XM(local_size)
     (int rnk, const ptrdiff_t *n, MPI_Comm comm,
      ptrdiff_t *local_n0, ptrdiff_t *local_0_start);
\end{verbatim}
\emph{FFTW 2d and 3d Basic interface:}
\begin{verbatim}
FFTW_EXTERN ptrdiff_t XM(local_size_2d)(
     ptrdiff_t n0, ptrdiff_t n1, MPI_Comm comm,
     ptrdiff_t *local_n0, ptrdiff_t *local_0_start);
FFTW_EXTERN ptrdiff_t XM(local_size_2d_transposed)(
     ptrdiff_t n0, ptrdiff_t n1, MPI_Comm comm,
     ptrdiff_t *local_n0, ptrdiff_t *local_0_start,
     ptrdiff_t *local_n1, ptrdiff_t *local_1_start);
FFTW_EXTERN ptrdiff_t XM(local_size_3d)(
     ptrdiff_t n0, ptrdiff_t n1, ptrdiff_t n2, MPI_Comm comm,
     ptrdiff_t *local_n0, ptrdiff_t *local_0_start);
FFTW_EXTERN ptrdiff_t XM(local_size_3d_transposed)(
     ptrdiff_t n0, ptrdiff_t n1, ptrdiff_t n2, MPI_Comm comm,
     ptrdiff_t *local_n0, ptrdiff_t *local_0_start,
     ptrdiff_t *local_n1, ptrdiff_t *local_1_start);
\end{verbatim}
\emph{FFTW 1d Basic Interface (not included in PFFT):}
\begin{verbatim}
ptrdiff_t XM(local_size_many_1d)(                   \
     ptrdiff_t n0, ptrdiff_t howmany,                           \
     MPI_Comm comm, int sign, unsigned flags,                   \
     ptrdiff_t *local_ni, ptrdiff_t *local_i_start,             \
     ptrdiff_t *local_no, ptrdiff_t *local_o_start);            \
ptrdiff_t XM(local_size_1d)(                        \
     ptrdiff_t n0, MPI_Comm comm, int sign, unsigned flags,     \
     ptrdiff_t *local_ni, ptrdiff_t *local_i_start,             \
     ptrdiff_t *local_no, ptrdiff_t *local_o_start);            \
\end{verbatim}





Transposed $d$-dimensional array distributed on $c$-dimensional process mesh ($c<d$)
\begin{equation*}
  \frac{n_1}{P_0} \times \frac{n_2}{P_1} \times \hdots \times \frac{n_c}{P_{c-1}}  \times n_0 \times n_{c+1} \times \hdots \times n_{d-1}
\end{equation*}

Comparision of non-transposed (left) and transposed (right) $d$-dimensional array for $c$-dimensional process mesh ($c<d$)
\begin{equation*}
  n_0\times n_1\times \hdots n_{c-1} \times n_c \hdots \times n_{d-1} \Rightarrow n_1 \times \hdots n_{c-1} \times n_0 \times n_c \times \hdots \times n_{d-1}
\end{equation*}







% \code{n}
% \code{comm\_cart\_2d}

\lstinputlisting[float, caption={Minimal PFFT test program.}, label=lst:min_c2c]{code/manual_min_c2c.c}




\section{Parallel FFT Frameworks}

\subsection{Forward Framework A (transposed input)}
\figurename{}~\ref{fig:fft_forw} lists the pseudo code of the parallel forward FFT framework.
\begin{figure}[ht]
  \begin{algorithmic}[1]
  %   \State\Comment{Calculate the serial FFTs row wise}
    \For{$t\gets0,\hdots,d-r-2$}
      \State $h_0 \gets \bigtimes_{s=0}^{r-1} N_s/P_s \times \bigtimes_{s=r}^{d-2-t} N_s$
      \State $N   \gets N_{d-1-t}$
      \State $h_1 \gets \bigtimes_{s=d-t}^{d-1} \hat N_s \times h$
      \State $h_0 \times N \times h_1 \osetarrow{FFT} h_0 \times \hat N \times h_1$
    \EndFor
    \For{$t\gets 0,\hdots,r-1$}
      \State $h_0 \gets \bigtimes_{s=r-t}^{r-1} \hat N_{s+1}/P_s \times \bigtimes_{s=0}^{r-t-1} N_s/P_s$
      \State $N   \gets N_{r-t}$
      \State $h_1 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $h_0 \times N \times h_1 \ousetarrow{FFT}{TO} \hat N \times h_0 \times h_1$
      \State
      \State $L_0 \gets \hat N_{r-t}$
      \State $h_0 \gets \bigtimes_{s=r-t}^{r-1}\hat N_{s+1}/P_{s} \times \bigtimes_{s=0}^{r-t-2} N_s/P_s$
      \State $L_1 \gets N_{r-t-1}$
      \State $h_1 \gets 1$
      \State $h_2 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $P   \gets P_{r-t-1}$
%       \State \mbox{$L_0 \times h_0 \times L_1/P \times h_1 \times h_2$} \mbox{$\ousetarrow{T}{TI} L_0/P \times h_0 \times L_1 \times h_1 \times h_2$}
      \State $L_0 \times h_0 \times L_1/P \times h_1 \times h_2\ousetarrow{T}{TI} L_0/P \times h_0 \times L_1 \times h_1 \times h_2$
    \EndFor
    \State $h_0 \gets \bigtimes_{s=0}^{r-1}\hat N_{s+1}/P_s$
    \State $N   \gets N_0$
    \State $h_1 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
    \State $h_0 \times N \times h_1 \osetarrow{FFT} h_0 \times \hat N \times h_1$
  \end{algorithmic}
  \caption{Parallel Forward FFT Framework}\label{fig:fft_forw}
\end{figure}

Within the first loop we use the serial FFT module~\eqref{eq:pruned_fft} to calculate
the one-dimensional (pruned) FFTs along the last $d-r-1$ array dimensions.
In the second loop we calculate $r$ one-dimensional pruned FFTs with transposed output~\eqref{eq:pruned_fft_to}
interleaved by global data transpositions with transposed input~\eqref{eq:gtransp_ti}.
Finally, a single non-transposed FFT~\eqref{eq:pruned_fft} must be computed to finish the full $d$-dimensional FFT.
The data decomposition of the output is then given by
\begin{equation*}
  \hat N_1/P_0 \times \hdots \times \hat N_{r-2}/P_{r-1} \times \hat N_r \times \hdots \times \hat N_{d-1} \times h\,.
\end{equation*}
Note, that the dimensions of the output array are slightly transposed.

\subsection{Backward Framework C (transposed output)}
Now, the parallel backward FFT framework can be derived very easy since we only need to revert all the steps
of the forward framework. The backward framework starts with the output decomposition of the forward framework
\begin{equation*}
  \hat N_1/P_0 \times \hdots \times \hat N_{r-2}/P_{r-1} \times \hat N_r \times \hdots \times \hat N_{d-1} \times h
\end{equation*}
and ends with the initial data decomposition
\begin{equation*}
  N_0/P_0 \times \hdots \times N_{r-1}/P_{r-1} \times N_r \times \hdots \times N_{d-1} \times h\,.
\end{equation*}
\figurename{}~\ref{fig:fft_back} lists the parallel backward FFT framework in pseudo code.
\begin{figure}[ht]
  \begin{algorithmic}[1]
  %   \State\Comment{Calculate the serial FFTs row wise}
    \State $h_0 \gets \bigtimes_{s=0}^{r-1}\hat N_{s+1}/P_s$
    \State $N   \gets \hat N_0$
    \State $h_1 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
    \State $h_0 \times \hat N \times h_1 \osetarrow{FFT} h_0 \times N \times h_1$
    \For{$t\gets r-1,\hdots,0$}
      \State $L_1 \gets \hat N_{r-t}$
      \State $h_1 \gets \bigtimes_{s=r-t}^{r-1}\hat N_{s+1}/P_{s} \times \bigtimes_{s=0}^{r-t-2} N_s/P_s$
      \State $L_0 \gets N_{r-t-1}$
      \State $h_0 \gets 1$
      \State $h_2 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $P   \gets P_{r-t-1}$
      \State $L_1/P \times h_1 \times L_0 \times h_0 \times h_2\ousetarrow{T}{TO} L_1 \times h_1 \times L_0/P \times h_0 \times h_2$
%       \State \mbox{$L_1/P \times h_1 \times L_0 \times h_0 \times h_2$} \mbox{$\ousetarrow{T}{TO} L_1 \times h_1 \times L_0/P \times h_0 \times h_2$}
      \State
      \State $h_0 \gets \bigtimes_{s=r-t}^{r-1} \hat N_{s+1}/P_s \times \bigtimes_{s=0}^{r-t-1} N_s/P_s$
      \State $N   \gets \hat N_{r-t}$
      \State $h_1 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $\hat N \times h_0 \times h_1 \ousetarrow{FFT}{TI} h_0 \times N \times h_1 $
    \EndFor
    \For{$t\gets d-r-2,\hdots,0$}
      \State $h_0 \gets \bigtimes_{s=0}^{r-1} N_s/P_s \times \bigtimes_{s=r}^{d-2-t} N_s$
      \State $N   \gets \hat N_{d-1-t}$
      \State $h_1 \gets \bigtimes_{s=d-t}^{d-1} \hat N_s \times h$
      \State $h_0 \times \hat N \times h_1 \osetarrow{FFT} h_0 \times N \times h_1$
    \EndFor
  \end{algorithmic}
  \caption{Parallel Backward FFT Framework}\label{fig:fft_back}
\end{figure}

\newpage
\subsection{Backward Framework A (transposed input) - General \texorpdfstring{$r$, $d$}{r, d}}
\setlength{\arraycolsep}{2pt}
\begin{equation*}
  \begin{array}{cc}
    & \frac{\hat N_1}{P_0} \times \hdots \times \frac{\hat N_r}{P_{r-1}} \times \hat N_0 \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \ousetarrow{FFT}{TO} & N_0 \times \frac{\hat N_1}{P_0} \times \hdots \times \frac{\hat N_r}{P_{r-1}} \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \transposearrow{TI} & \frac{N_0}{P_0} \times \hat N_1 \times \frac{\hat N_2}{P_1} \times \hdots \times \frac{\hat N_r}{P_{r-1}} \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \ousetarrow{FFT}{TO} & N_1 \times \frac{N_0}{P_0} \times \frac{\hat N_2}{P_1} \times \hdots \times \frac{\hat N_r}{P_{r-1}} \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \vdots & \\
    \transposearrow{TI} & \frac{N_{r-1}}{P_{r-1}} \times \hdots \times \frac{N_0}{P_0} \times \hat N_r \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \ousetarrow{FFT}{\red{T}} & \frac{N_0}{P_0} \times \hdots \times \frac{N_{r-1}}{P_{r-1}} \times N_r \times \hat N_{r+1} \times \hdots \times \hat N_{d-1} \times h \\
    \ousetarrow{FFT}{} & \frac{N_0}{P_0} \times \hdots \times \frac{N_{r-1}}{P_{r-1}} \times N_r \times N_{r+1} \times \hat N_{r+2} \times \hdots \times \hat N_{d-1} \times h \\
    \vdots & \\
    \ousetarrow{FFT}{} & \frac{N_0}{P_0} \times \hdots \times \frac{N_{r-1}}{P_{r-1}} \times N_r \times N_{r+1} \times \hdots \times N_{d-1} \times h \\
  \end{array}
\end{equation*}

\newpage
\subsection{Backward Framework A (transposed input) for \texorpdfstring{$r=3$, $d=5$}{r=3 and d=5}}
\setlength{\arraycolsep}{2pt}
\begin{equation*}
  \begin{array}{cccc}
    & \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \hat N_0 \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \Big(N_0\Big) \times \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \left(\frac{N_0}{P_0}\right) \times \hat N_1 \times \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \left(N_1 \times \frac{N_0}{P_0}\right) \times \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \left(\frac{N_1}{P_1} \times \frac{N_0}{P_0}\right) \times \hat N_2 \times \left(\frac{\hat N_3}{P_2} \times \hat N_4 \times h \right)
    & \ousetarrow{FFT}{TO} & \left(N_2 \times \frac{N_1}{P_1} \times \frac{N_0}{P_0}\right) \times \left(\frac{\hat N_3}{P_2} \right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \frac{N_2}{P_2} \times \frac{N_1}{P_1} \times \frac{N_0}{P_0} \times \left(\hat N_3 \times \hat N_4 \times h \right)
    & \ousetarrow{FFT}{\red{T}} & \frac{N_0}{P_0} \times \frac{N_1}{P_1} \times \frac{N_2}{P_2} \times N_3 \times N_4 \times h
  \end{array}
\end{equation*}
Last step need more general interface to serial FFT module!

\subsection{Backward Framework B (transposed input and output) for \texorpdfstring{$r=3$, $d=5$}{r=3 and d=5}}
\setlength{\arraycolsep}{2pt}
\begin{equation*}
  \begin{array}{cccc}
    & \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \hat N_0 \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \Big(N_0\Big) \times \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & \hat N_1 \times \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times \left(\hat N_4 \times h\right)
    & \osetarrow{FFT} & \Big(N_1\Big) \times \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & \hat N_2 \times \left(\frac{\hat N_3}{P_2} \times \frac{N_0}{P_0} \times \frac{N_1}{P_1}\right) \times \left(\hat N_4 \times h\right)
    & \osetarrow{FFT} & \Big(N_2\Big) \times \left(\frac{\hat N_3}{P_2} \times \frac{N_0}{P_0} \times \frac{N_1}{P_1}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & \hat N_3 \times \left(\frac{N_0}{P_0} \times \frac{N_1}{P_1}  \times \frac{N_2}{P_2}\right) \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TI} & \frac{N_0}{P_0} \times \frac{N_1}{P_1}  \times \frac{N_2}{P_2} \times N_3 \times N_4 \times h
  \end{array}
\end{equation*}

\subsection{Forward Framework A (transposed input) for \texorpdfstring{$r=3$, $d=5$}{r=3 and d=5}}
\setlength{\arraycolsep}{2pt}
\begin{equation*}
  \begin{array}{cccc}
    & \left(\frac{N_0}{P_0} \times \frac{N_1}{P_1}  \times \frac{N_2}{P_2}\right) \times N_3 \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \left(\hat N_3 \times \frac{N_0}{P_0} \times \frac{N_1}{P_1}\right) \times \left(\frac{N_2}{P_2}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \left(\frac{\hat N_3}{P_2} \times \frac{N_0}{P_0} \times \frac{N_1}{P_1}\right)  \times N_2 \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \left(\hat N_2 \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times \left(\frac{N_1}{P_1}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times N_1 \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \left(\hat N_1 \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \left(\frac{N_0}{P_0}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TI} & \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times N_0 \times \left(\hat N_4 \times h\right)
    & \osetarrow{FFT} & \frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \hat N_0 \times \hat N_4 \times h
  \end{array}
\end{equation*}

\subsection{Forward Framework B (transposed input and output) for \texorpdfstring{$r=3$, $d=5$}{r=3 and d=5}}
\setlength{\arraycolsep}{2pt}
\begin{equation*}
  \begin{array}{cccc}
    & \left(\frac{N_0}{P_0} \times \frac{N_1}{P_1}  \times \frac{N_2}{P_2}\right) \times N_3 \times \left(N_4 \times h\right)
    & \ousetarrow{FFT}{TO} & \left(\hat N_3 \times \frac{N_0}{P_0} \times \frac{N_1}{P_1}\right)  \times \left(\frac{N_2}{P_2}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & N_2 \times \left(\frac{\hat N_3}{P_2} \times \frac{N_0}{P_0} \times \frac{N_1}{P_1} \right) \times \left( \hat N_4 \times h\right)
    & \osetarrow{FFT} & \left(\hat N_2 \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times \left(\frac{N_1}{P_1}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & N_1 \times \left(\frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \frac{N_0}{P_0}\right) \times \left( \hat N_4 \times h\right)
    & \osetarrow{FFT} & \left(\hat N_1 \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \left(\frac{N_0}{P_0}\right) \times \left(\hat N_4 \times h\right) \\
    \transposearrow{TIO} & N_0 \times \left(\frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2}\right) \times \left(\hat N_4 \times h\right)
    & \ousetarrow{FFT}{TI} & \frac{\hat N_1}{P_0} \times \frac{\hat N_2}{P_1} \times \frac{\hat N_3}{P_2} \times \hat N_0 \times \hat N_4 \times h
  \end{array}
\end{equation*}

\newpage
\subsection{Backward Framework A (transposed input) - The general form}
\figurename{}~\ref{fig:fft_back_A} lists the parallel backward FFT framework A in pseudo code.
\begin{figure}[ht]
  \begin{algorithmic}[1]
  %   \State\Comment{Calculate the serial FFTs row wise}
    \For{$t\gets 0,\hdots,r-1$}
      \State $h_0 \gets \bigtimes_{s=t}^{r-1}\hat N_{s+1}/P_s$
      \State $N   \gets \hat N_t$
      \State $h_1 \gets \bigtimes_{s=t+1}^{r-1} \hat N_{s+1} / P_{s} \times \hat N_{r}  \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $h_0 \times \hat N \times h_1 \ousetarrow{FFT}{TO} N \times h_0 \times h_1$
      \State
      \State $L_1 \gets N_t$
      \State $h_1 \gets \bigtimes_{s=0}^{t-1} N_{s}/P_{s}$
      \State $L_0 \gets \hat N_{t+1}$
      \State $h_0 \gets \bigtimes_{s=t+1}^{r-1}\hat N_{s+1}/P_{s}$
      \State $h_2 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
      \State $P   \gets P_{t}$
      \State $L_1 \times h_1 \times L_0/P \times h_0 \times h_2\ousetarrow{T}{TI} L_1/P \times h_1 \times L_0 \times h_0 \times h_2$
    \EndFor
    \State $h_0 \gets \bigtimes_{s=r-t}^{r-1} \hat N_{s+1}/P_s \times \bigtimes_{s=0}^{r-t-1} N_s/P_s$
    \State $N   \gets \hat N_{r-t}$
    \State $h_1 \gets \bigtimes_{s=r+1}^{d-1} \hat N_s \times h$
    \State $\hat N \times h_0 \times h_1 \ousetarrow{FFT}{TI} h_0 \times N \times h_1 $
    \For{$t\gets d-r-2,\hdots,0$}
      \State $h_0 \gets \bigtimes_{s=0}^{r-1} N_s/P_s \times \bigtimes_{s=r}^{d-2-t} N_s$
      \State $N   \gets \hat N_{d-1-t}$
      \State $h_1 \gets \bigtimes_{s=d-t}^{d-1} \hat N_s \times h$
      \State $h_0 \times \hat N \times h_1 \osetarrow{FFT} h_0 \times N \times h_1$
    \EndFor
  \end{algorithmic}
  \caption{Parallel Backward FFT Framework A}\label{fig:fft_back_A}
\end{figure}





